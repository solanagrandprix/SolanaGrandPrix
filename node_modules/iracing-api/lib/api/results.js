import { API } from './api';
/**
 * Provides methods for interacting with session result endpoints.
 */
export class ResultsAPI extends API {
    constructor() {
        super(...arguments);
        /**
         * Get the results of a specific subsession.
         *
         * Note: `series_logo` image paths in response are relative to `https://images-static.iracing.com/img/logos/series/`.
         *
         * @param {GetResultParams} params - Parameters for the request.
         * @param {number} params.subsessionId - The ID of the subsession.
         * @param {boolean} [params.includeLicenses=false] - Include license information in the response.
         *
         * @returns A promise resolving to the race result data, or undefined on error.
         */
        this.getResult = async (params) => await this._getData('data/results/get', {
            subsession_id: params.subsessionId,
            include_licenses: params.includeLicenses,
        });
        /**
         * Get the event log for a specific subsession and simsession.
         *
         * @param {GetResultsEventLogParams} params - Parameters for the request.
         * @param {number} params.subsessionId - The ID of the subsession.
         * @param {number} params.simsessionNumber - The simsession number (0 for main event, -1 for preceding, etc.).
         * @param {Object} [options] - Options for fetching data.
         * @param {boolean} [options.getAllChunks=false] - If true, fetch and combine data from all chunks (if applicable).
         *
         * @returns A promise resolving to the event log data, potentially combined from chunks, or throws an error if fetching fails.
         */
        this.getResultsEventLog = async (params, options) => {
            const data = await this._getData('data/results/event_log', {
                subsession_id: params.subsessionId,
                simsession_number: params.simsessionNumber,
            });
            if (!data) {
                throw new Error('Failed to fetch event log data');
            }
            if (!(options === null || options === void 0 ? void 0 : options.getAllChunks) || !data.chunkInfo)
                return data;
            const chunkData = await Promise.all(data.chunkInfo.chunkFileNames.map((chunkFileName) => {
                return this._getLinkData(`${data.chunkInfo.baseDownloadUrl}${chunkFileName}`);
            }));
            return Object.assign(Object.assign({}, data), { eventLog: chunkData.flatMap((chunk) => chunk) });
        };
        /**
         * Get lap chart data for a specific subsession and simsession.
         *
         * @param {GetResultsLapChartDataParams} params - Parameters for the request.
         * @param {number} params.subsessionId - The ID of the subsession.
         * @param {number} params.simsessionNumber - The simsession number (0 for main event, -1 for preceding, etc.).
         * @param {Object} [options] - Options for fetching data.
         * @param {boolean} [options.getAllChunks=false] - If true, fetch and combine data from all chunks (if applicable).
         *
         * @returns A promise resolving to the lap chart data, potentially combined from chunks, or throws an error if fetching fails.
         */
        this.getResultsLapChartData = async (params, options) => {
            var _a, _b, _c;
            const data = await this._getData('data/results/lap_chart_data', {
                subsession_id: params.subsessionId,
                simsession_number: params.simsessionNumber,
            });
            if (!data) {
                throw new Error('Failed to fetch lap chart data');
            }
            if (!(options === null || options === void 0 ? void 0 : options.getAllChunks))
                return data;
            const chunkData = await Promise.all((_c = (_b = (_a = data.chunkInfo) === null || _a === void 0 ? void 0 : _a.chunkFileNames) === null || _b === void 0 ? void 0 : _b.map((chunkFileName) => {
                var _a;
                return this._getLinkData(`${(_a = data.chunkInfo) === null || _a === void 0 ? void 0 : _a.baseDownloadUrl}${chunkFileName}`);
            })) !== null && _c !== void 0 ? _c : []);
            return Object.assign(Object.assign({}, data), { lapChartData: chunkData.flatMap((chunk) => chunk) });
        };
        /**
         * Get lap data for a driver or team in a specific subsession and simsession.
         *
         * @param {GetResultsLapDataParams} params - Parameters for the request.
         * @param {number} params.subsessionId - The ID of the subsession.
         * @param {number} params.simsessionNumber - The simsession number (0 for main event, -1 for preceding, etc.).
         * @param {number} [params.customerId] - Required for single-driver events. Optional for team events (returns all team laps if omitted).
         * @param {number} [params.teamId] - Required for team events.
         *
         * @param {GetResultsLapDataOptions} [options] - Options for fetching data.
         * @param {boolean} [options.getAllChunks=false] - If true, fetch and combine data from all chunks (if applicable).
         *
         * @returns A promise resolving to the lap data, potentially combined from chunks, or throws an error if fetching fails.
         */
        this.getResultsLapData = async (params, options) => {
            var _a, _b, _c;
            const data = await this._getData('data/results/lap_data', {
                subsession_id: params.subsessionId,
                simsession_number: params.simsessionNumber,
                cust_id: params.customerId,
                team_id: params.teamId,
            });
            if (!data) {
                throw new Error('Failed to fetch lap data');
            }
            if (!(options === null || options === void 0 ? void 0 : options.getAllChunks))
                return data;
            const chunkData = await Promise.all((_c = (_b = (_a = data.chunkInfo) === null || _a === void 0 ? void 0 : _a.chunkFileNames) === null || _b === void 0 ? void 0 : _b.map((chunkFileName) => {
                var _a;
                return this._getLinkData(`${(_a = data.chunkInfo) === null || _a === void 0 ? void 0 : _a.baseDownloadUrl}${chunkFileName}`);
            })) !== null && _c !== void 0 ? _c : []);
            return Object.assign(Object.assign({}, data), { lapData: chunkData.flatMap((chunk) => chunk) });
        };
        /**
         * Search for hosted and league session results.
         *
         * Note: Maximum time frame is 90 days. Results may be split into chunks.
         * Requires one time range (`start_range_begin` or `finish_range_begin`).
         * Requires one identifier (`custId`, `teamId`, `hostCustId`, `sessionName`).
         *
         * @param {SearchHostedParams} [params] - Search parameters.
         * @param {string} [params.startRangeBegin] - Session start time range begin (ISO-8601 UTC).
         * @param {string} [params.startRangeEnd] - Session start time range end (ISO-8601 UTC, exclusive).
         * @param {string} [params.finishRangeBegin] - Session finish time range begin (ISO-8601 UTC).
         * @param {string} [params.finishRangeEnd] - Session finish time range end (ISO-8601 UTC, exclusive).
         * @param {number} [params.custId] - Participant's customer ID (ignored if `teamId` provided).
         * @param {number} [params.teamId] - Team ID (takes priority over `custId`).
         * @param {number} [params.hostCustId] - Host's customer ID.
         * @param {string} [params.sessionName] - Partial or full session name.
         * @param {number} [params.leagueId] - Filter by league ID.
         * @param {number} [params.leagueSeasonId] - Filter by league season ID.
         * @param {number} [params.carId] - Filter by car ID used in the session.
         * @param {number} [params.trackId] - Filter by track ID used in the session.
         * @param {number[]} [params.categoryIds] - Filter by track category IDs (defaults to all).
         *
         * @returns A promise resolving to the search results (possibly chunked), or undefined on error.
         */
        this.searchHosted = async (params) => {
            var _a;
            return await this._getData('data/results/search_hosted', {
                start_range_begin: params === null || params === void 0 ? void 0 : params.startRangeBegin,
                start_range_end: params === null || params === void 0 ? void 0 : params.startRangeEnd,
                finish_range_begin: params === null || params === void 0 ? void 0 : params.finishRangeBegin,
                finish_range_end: params === null || params === void 0 ? void 0 : params.finishRangeEnd,
                cust_id: params === null || params === void 0 ? void 0 : params.custId,
                team_id: params === null || params === void 0 ? void 0 : params.teamId,
                host_cust_id: params === null || params === void 0 ? void 0 : params.hostCustId,
                session_name: params === null || params === void 0 ? void 0 : params.sessionName,
                league_id: params === null || params === void 0 ? void 0 : params.leagueId,
                league_season_id: params === null || params === void 0 ? void 0 : params.leagueSeasonId,
                car_id: params === null || params === void 0 ? void 0 : params.carId,
                track_id: params === null || params === void 0 ? void 0 : params.trackId,
                category_ids: (_a = params === null || params === void 0 ? void 0 : params.categoryIds) === null || _a === void 0 ? void 0 : _a.join(','),
            });
        };
        /**
         * Search for official series results.
         *
         * Note: Maximum time frame is 90 days. Results may be split into chunks.
         * Requires at least one time filter (`season_year`/`season_quarter`, `start_range_begin`, or `finish_range_begin`).
         *
         * @param {SearchSeriesParams} [params] - Search parameters.
         * @param {number} [params.seasonYear] - Season year (requires `seasonQuarter`).
         * @param {number} [params.seasonQuarter] - Season quarter (requires `seasonYear`).
         * @param {string} [params.startRangeBegin] - Session start time range begin (ISO-8601 UTC).
         * @param {string} [params.startRangeEnd] - Session start time range end (ISO-8601 UTC, exclusive).
         * @param {string} [params.finishRangeBegin] - Session finish time range begin (ISO-8601 UTC).
         * @param {string} [params.finishRangeEnd] - Session finish time range end (ISO-8601 UTC, exclusive).
         * @param {number} [params.customerId] - Participant's customer ID (ignored if `teamId` provided).
         * @param {number} [params.teamId] - Team ID (takes priority over `customerId`).
         * @param {number} [params.seriesId] - Filter by series ID.
         * @param {number} [params.raceWeekNum] - Filter by race week number (0-based).
         * @param {boolean} [params.officialOnly=false] - Include only official sessions earning points.
         * @param {number[]} [params.eventTypes] - Filter by event type IDs (defaults to all).
         * @param {number[]} [params.categoryIds] - Filter by license category IDs (defaults to all).
         *
         * @returns A promise resolving to the search results (potentially combined from chunks), or the raw chunk info response if chunk fetching is not implemented/fails.
         */
        this.searchSeries = async (params) => {
            var _a, _b, _c, _d;
            const responseData = await this._getData('data/results/search_series', {
                season_year: params === null || params === void 0 ? void 0 : params.seasonYear,
                season_quarter: params === null || params === void 0 ? void 0 : params.seasonQuarter,
                start_range_begin: params === null || params === void 0 ? void 0 : params.startRangeBegin,
                start_range_end: params === null || params === void 0 ? void 0 : params.startRangeEnd,
                finish_range_begin: params === null || params === void 0 ? void 0 : params.finishRangeBegin,
                finish_range_end: params === null || params === void 0 ? void 0 : params.finishRangeEnd,
                cust_id: params === null || params === void 0 ? void 0 : params.customerId,
                team_id: params === null || params === void 0 ? void 0 : params.teamId,
                series_id: params === null || params === void 0 ? void 0 : params.seriesId,
                race_week_num: params === null || params === void 0 ? void 0 : params.raceWeekNum,
                official_only: params === null || params === void 0 ? void 0 : params.officialOnly,
                event_types: (_a = params === null || params === void 0 ? void 0 : params.eventTypes) === null || _a === void 0 ? void 0 : _a.join(','),
                category_ids: (_b = params === null || params === void 0 ? void 0 : params.categoryIds) === null || _b === void 0 ? void 0 : _b.join(','),
            });
            if (!((_c = responseData === null || responseData === void 0 ? void 0 : responseData.data) === null || _c === void 0 ? void 0 : _c.success) || !((_d = responseData === null || responseData === void 0 ? void 0 : responseData.data) === null || _d === void 0 ? void 0 : _d.chunk_info)) {
                return responseData;
            }
            const { data: { chunk_info: { base_download_url, chunk_file_names }, }, } = responseData;
            const chunksData = await Promise.all(chunk_file_names.map(async (chunkFileName) => {
                return await this._getLinkData(`${base_download_url}${chunkFileName}`);
            }));
            return chunksData.flatMap((chunk) => chunk);
        };
        /**
         * Get results for a specific season, optionally filtered by event type and race week.
         *
         * @param {GetSeasonResultsParams} params - Parameters for the request.
         * @param {number} params.seasonId - The ID of the season.
         * @param {number} [params.eventType] - Filter by event type ID (2=Practice, 3=Qualify, 4=Time Trial, 5=Race).
         * @param {number} [params.raceWeekNumber] - Filter by race week number (0-based).
         *
         * @returns A promise resolving to the season results data, or undefined on error.
         */
        this.getSeasonResults = async (params) => await this._getData('data/results/season_results', {
            season_id: params.seasonId,
            event_type: params.eventType,
            race_week_num: params.raceWeekNumber,
        });
    }
}
